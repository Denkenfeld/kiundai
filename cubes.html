<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Menger Sponge (Twigl Style)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        if (!gl) { alert('WebGL not supported'); }

        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() { gl_Position = aVertexPosition; }
        `;

        // Twigl/Code Golf style Raymarcher
        // Features: Infinite Menger Sponge, Edge Glow, Camera Rotation
        const fsSource = `
            precision highp float;
            uniform vec2 iResolution;
            uniform float iTime;

            // Rotation matrix
            mat2 rot(float a) {
                float s = sin(a), c = cos(a);
                return mat2(c, -s, s, c);
            }

            // Box Signed Distance Function
            float sdBox(vec3 p, vec3 b) {
                vec3 q = abs(p) - b;
                return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
            }

            // Menger Sponge Fractal
            float map(vec3 p) {
                // Infinite repetition
                p = mod(p, 4.0) - 2.0;

                float d = sdBox(p, vec3(1.0)); // Base box
                float s = 1.0;
                
                // Fold 3 times for detail
                for(int i = 0; i < 3; i++) {
                    vec3 a = mod(p * s, 2.0) - 1.0;
                    s *= 3.0;
                    vec3 r = abs(1.0 - 3.0 * abs(a));
                    float da = max(r.x, r.y);
                    float db = max(r.y, r.z);
                    float dc = max(r.z, r.x);
                    float c = (min(da, min(db, dc)) - 1.0) / s;
                    d = max(d, c);
                }
                return d;
            }

            void mainImage(out vec4 fragColor, in vec2 fragCoord) {
                vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;
                
                // Camera setup
                vec3 ro = vec3(0.0, 0.0, iTime * 2.0); // Move camera forward
                vec3 rd = normalize(vec3(uv, 1.0));
                
                // Rotate camera slightly for "floaty" feel
                rd.xy *= rot(iTime * 0.1);
                rd.xz *= rot(sin(iTime * 0.2) * 0.5);

                float t = 0.0;
                float d = 0.0;
                vec3 p;
                
                // Raymarching loop
                // "i" is used for glow accumulation
                float glow = 0.0;
                for(int i = 0; i < 80; i++) {
                    p = ro + rd * t;
                    d = map(p);
                    t += d;
                    
                    // Accumulate glow based on how close we are to geometry
                    // This creates the "neon edge" look common in Twigl shaders
                    glow += 0.01 / (0.01 + abs(d));
                    
                    if(d < 0.001 || t > 100.0) break;
                }

                // Color logic
                vec3 col = vec3(0.0);
                
                if(d < 0.001) {
                    // Surface lighting (basic normals)
                    // We cheat normals by sampling map() again slightly offset
                    vec2 e = vec2(0.001, 0.0);
                    vec3 n = normalize(vec3(
                        map(p + e.xyy) - map(p - e.xyy),
                        map(p + e.yxy) - map(p - e.yxy),
                        map(p + e.yyx) - map(p - e.yyx)
                    ));
                    
                    // Simple lighting
                    col = vec3(0.1) + vec3(0.5, 0.7, 1.0) * max(0.0, dot(n, -rd));
                }
                
                // Add the accumulated glow (Twigl signature style)
                // Color palette: Cyan and Purple/Pink
                col += vec3(0.2, 0.5, 1.0) * glow * 0.02;
                col += vec3(1.0, 0.2, 0.5) * glow * 0.01 * (sin(iTime) + 1.0);

                // Fog to hide the distance clipping
                col = mix(col, vec3(0.0), 1.0 - exp(-0.05 * t));

                fragColor = vec4(col, 1.0);
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
        gl.linkProgram(program);

        const uRes = gl.getUniformLocation(program, 'iResolution');
        const uTime = gl.getUniformLocation(program, 'iTime');
        const buffer = gl.createBuffer();
        
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1, 1,1, -1,-1, 1,-1]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(gl.getAttribLocation(program, 'aVertexPosition'));
        gl.vertexAttribPointer(gl.getAttribLocation(program, 'aVertexPosition'), 2, gl.FLOAT, false, 0, 0);

        function render(time) {
            if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            gl.useProgram(program);
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1f(uTime, time * 0.001);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
