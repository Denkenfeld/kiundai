<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Pilot Gyroid Flight</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        if (!gl) { document.body.innerHTML = 'WebGL Not Supported'; }

        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() { gl_Position = aVertexPosition; }
        `;

        const fsSource = `
            precision highp float;
            uniform vec2 iResolution;
            uniform float iTime;

            // --- 1. PATH GENERATOR ---
            // This function defines the curvy path the camera takes.
            // We use this for the camera position AND to carve the tunnel.
            vec2 get_path(float z) {
                return vec2(
                    sin(z * 0.3) * 2.0, // Sway Left/Right
                    cos(z * 0.2) * 1.5  // Sway Up/Down
                );
            }

            // Smooth Maximum: Blends two shapes together smoothly
            // We use this to melt the walls away from the path
            float smax(float a, float b, float k) {
                float h = max(k - abs(a - b), 0.0);
                return max(a, b) + h * h * 0.25 / k;
            }

            // --- 2. GEOMETRY MAP ---
            // Gyroid function + Safety Carving
            float gyroid(vec3 p) {
                return dot(sin(p), cos(p.yzx));
            }

            float map(vec3 p) {
                float scale = 0.8;
                
                // Base Organic Shape
                float d = gyroid(p * scale) * 0.7;
                d += gyroid(p * scale * 1.6 + iTime * 0.3) * 0.3;
                
                // Make it a hollow shell
                d = abs(d) - 0.1; 

                // --- SAFETY CARVING ---
                // Calculate where the "safe path" is at this Z-depth
                vec2 pathPos = get_path(p.z);
                
                // Distance from the current point 'p' to the safe path center
                float distToPath = length(p.xy - pathPos);
                
                // "Tube" of empty space radius 0.6
                // If we are closer than 0.6 to the path, this value becomes positive
                // and pushes the distance function 'd' outwards.
                float safetyTube = 0.6 - distToPath;
                
                // Blend the Safety Tube with the Gyroid using smax
                // This "melts" the geometry if it gets in the way
                return smax(d, safetyTube, 0.4); 
            }

            // --- 3. COLOR & TEXTURE ---
            vec3 getMaterial(vec3 p, vec3 n) {
                // Texture grid
                vec3 q = fract(p * 2.0) - 0.5;
                float pat = length(q);
                
                // Colors: Purple, Orange, Pink
                vec3 col = mix(
                    vec3(0.3, 0.0, 0.8), // Deep Violet
                    vec3(1.0, 0.5, 0.1), // Neon Orange
                    smoothstep(-0.6, 0.6, sin(p.z * 0.3 + p.y * 0.5)) 
                );

                // Pink Highlights
                col = mix(col, vec3(1.0, 0.1, 0.6), smoothstep(0.1, 0.2, pat));
                
                // Dots Texture
                float dots = smoothstep(0.25, 0.3, length(q));
                col *= 0.3 + 0.7 * dots; // Contrast dots

                return col;
            }

            void mainImage(out vec4 fragColor, in vec2 fragCoord) {
                vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;
                
                // --- 4. ADVANCED CAMERA SYSTEM ---
                float tVal = iTime * 1.5; // Speed
                
                // Camera Position (RO) follows the path
                vec3 ro = vec3(get_path(tVal), tVal);
                
                // Look-At Target (TA) is slightly ahead on the path
                vec3 ta = vec3(get_path(tVal + 1.0), tVal + 1.0);
                
                // Construct Camera Matrix (to look at TA)
                vec3 fwd = normalize(ta - ro);
                vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), fwd));
                vec3 up = cross(fwd, right);
                vec3 rd = normalize(fwd + right * uv.x + up * uv.y);

                // Raymarching
                float t = 0.0;
                vec3 p = ro;
                int hit = 0;
                
                for(int i = 0; i < 120; i++) {
                    p = ro + rd * t;
                    float d = map(p);
                    
                    if(d < 0.001) { hit = 1; break; }
                    if(t > 40.0) break;
                    
                    t += d * 0.6; // Step
                }

                // Rendering
                vec3 col = vec3(0.0);
                if(hit == 1) {
                    vec2 e = vec2(0.001, 0.0);
                    vec3 n = normalize(vec3(
                        map(p + e.xyy) - map(p - e.xyy),
                        map(p + e.yxy) - map(p - e.yxy),
                        map(p + e.yyx) - map(p - e.yyx)
                    ));
                    
                    vec3 mat = getMaterial(p, n);
                    
                    // Lighting that travels with camera
                    vec3 lightPos = ro + vec3(0.0, 0.5, 1.0);
                    vec3 l = normalize(lightPos - p);
                    
                    float diff = max(dot(n, l), 0.0);
                    float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 20.0);
                    
                    // Rim light for depth
                    float rim = pow(1.0 - max(dot(n, -rd), 0.0), 3.0);
                    
                    col = mat * (diff * 0.6 + 0.4);
                    col += vec3(1.0, 0.8, 0.8) * spec * 0.6; // Glossy highlight
                    col += vec3(0.5, 0.2, 1.0) * rim * 0.5; // Purple rim glow
                    
                    // Distance Fog
                    col = mix(col, vec3(0.05, 0.0, 0.1), 1.0 - exp(-0.06 * t));
                } else {
                    // Dark void background
                    col = vec3(0.05, 0.0, 0.1);
                }

                fragColor = vec4(col, 1.0);
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return gl.getShaderParameter(shader, gl.COMPILE_STATUS) ? shader : null;
        }

        const program = gl.createProgram();
        const vShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
        gl.attachShader(program, vShader);
        gl.attachShader(program, fShader);
        gl.linkProgram(program);

        const uRes = gl.getUniformLocation(program, 'iResolution');
        const uTime = gl.getUniformLocation(program, 'iTime');
        const buffer = gl.createBuffer();
        
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1, 1,1, -1,-1, 1,-1]), gl.STATIC_DRAW);
        const aPos = gl.getAttribLocation(program, 'aVertexPosition');
        gl.enableVertexAttribArray(aPos);
        gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

        function render(time) {
            if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }
            gl.useProgram(program);
            gl.uniform2f(uRes, canvas.width, canvas.height);
            gl.uniform1f(uTime, time * 0.001);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
