<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Fractal Zoom (WebGL)</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

        if (!gl) {
            alert('Your browser does not support WebGL.');
        }

        // --- GLSL VERTEX SHADER ---
        // Basic full-screen quad setup
        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() {
                gl_Position = aVertexPosition;
            }
        `;

        // --- GLSL FRAGMENT SHADER ---
        // Replicates the "Cool Fractal Zoom" style using KIFS (Kaleidoscopic IFS) logic
        // This creates an infinite, glowing geometric tunnel.
        const fsSource = `
            precision highp float;
            
            uniform vec2 iResolution;
            uniform float iTime;

            // Palette function for the "cool" neon colors
            vec3 palette(float t) {
                vec3 a = vec3(0.5, 0.5, 0.5);
                vec3 b = vec3(0.5, 0.5, 0.5);
                vec3 c = vec3(1.0, 1.0, 1.0);
                vec3 d = vec3(0.263, 0.416, 0.557);
                return a + b * cos(6.28318 * (c * t + d));
            }

            // 2D Rotation matrix
            mat2 rot(float a) {
                float s = sin(a);
                float c = cos(a);
                return mat2(c, -s, s, c);
            }

            void mainImage(out vec4 fragColor, in vec2 fragCoord) {
                vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;
                vec2 uv0 = uv; // Store original UVs
                vec3 finalColor = vec3(0.0);

                // --- FRACTAL ZOOM LOGIC ---
                // We iterate to create layers of the fractal
                for (float i = 0.0; i < 4.0; i++) {
                    
                    // Domain repetition / Fractal folding
                    // fract() creates the repetition, -0.5 centers it
                    uv = fract(uv * 1.5) - 0.5;

                    // The "Zoom" effect comes from scale accumulation and time
                    float d = length(uv) * exp(-length(uv0)); 

                    // Color palette cycling based on length and time
                    vec3 col = palette(length(uv0) + i * 0.4 + iTime * 0.4);

                    // Create the glowing rings/structures
                    d = sin(d * 8.0 + iTime) / 8.0;
                    d = abs(d);
                    
                    // Inverse power creates the "glow" (neon effect)
                    d = pow(0.01 / d, 1.2);

                    // Add to final color (additive blending)
                    finalColor += col * d;
                }

                fragColor = vec4(finalColor, 1.0);
            }

            // Standard Shadertoy wrapper
            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        `;

        // --- WEBGL BOILERPLATE ---
        // Compiles shader, links program, and handles the render loop

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(shaderProgram));
        }

        // Look up uniform locations
        const uResolution = gl.getUniformLocation(shaderProgram, 'iResolution');
        const uTime = gl.getUniformLocation(shaderProgram, 'iTime');
        const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'aVertexPosition');

        // Create a buffer for the square (2 triangles) that covers the screen
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1.0,  1.0,
             1.0,  1.0,
            -1.0, -1.0,
             1.0, -1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        // Rendering Function
        function render(time) {
            // Resize canvas to match display size
            if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
                gl.viewport(0, 0, canvas.width, canvas.height);
            }

            gl.useProgram(shaderProgram);

            // Bind position buffer
            gl.enableVertexAttribArray(positionAttributeLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

            // Set Uniforms
            gl.uniform2f(uResolution, canvas.width, canvas.height);
            gl.uniform1f(uTime, time * 0.001); // Convert ms to seconds

            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
